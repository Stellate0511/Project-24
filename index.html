<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PROJECT: 24</title>
    <style>
        /* === 1. 全局变量定义 === */
        :root {
            /* --- 默认主题 (Dark / Cyber) --- */
            --bg-color: #020408;
            --win-bg: #050a14;
            --primary-color: #00f3ff;
            --secondary-color: #005f73;
            --alert-color: #ff2a6d;
            --success-color: #00ff9d;
            --text-color: #e0fbfc;
            --card-w: 65px;
            --card-h: 95px;
            
            /* 字体与风格变量 */
            --font-main: 'Courier New', Courier, monospace;
            --radius-main: 0px; 
            --shadow-glow: 0 0 50px rgba(0, 243, 255, 0.08);
            --btn-bg: rgba(0, 95, 115, 0.15);
            --card-bg: rgba(8, 20, 30, 0.6);
            --text-glow: 0 0 10px; /* 控制文字发光开关 */
            --deco-display: block; /* 控制赛博角标显示 */
        }

        /* === 2. 亮色/可爱主题 (Light / Cute) === */
        html[data-theme="light"] {
            /* 背景：暖米白 */
            --bg-color: #f9f7f2; 
            --win-bg: #ffffff;
            
            /* 配色：樱花粉、天空蓝、薄荷绿 */
            --primary-color: #ff8fab; 
            --secondary-color: #8d99ae;
            --alert-color: #ff6b6b;
            --success-color: #4ecdc4;
            --text-color: #555b6e;
            
            /* 风格：圆润、无衬线、实心投影 */
            --font-main: "Nunito", "Quicksand", system-ui, sans-serif;
            --radius-main: 20px;
            --shadow-glow: 0 10px 30px rgba(0,0,0,0.08);
            --btn-bg: #f0f0f0;
            --card-bg: #ffffff;
            --text-glow: 0 0 0; /* 关闭发光 */
            --deco-display: none; /* 隐藏角标 */
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            background-color: var(--bg-color);
            /* 默认暗色渐变，亮色模式会被下面的 override 覆盖 */
            background-image: radial-gradient(circle at center, #0a1525 0%, #000 100%);
            color: var(--text-color);
            font-family: var(--font-main);
            min-height: 100vh;
            min-height: 100dvh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            transition: background-color 0.5s, color 0.3s; /* 主题切换动画 */
        }
        
        /* 亮色模式移除背景渐变 */
        html[data-theme="light"] body {
            background-image: none;
        }

        /* --- 主窗口 --- */
        #main-window {
            width: 95%; max-width: 800px;
            height: 90vh; height: 90dvh;
            max-height: 750px; min-height: 500px;
            background: var(--win-bg);
            border: 1px solid var(--secondary-color);
            box-shadow: var(--shadow-glow);
            position: relative;
            display: flex; flex-direction: column;
            
            /* 主题变量控制圆角 */
            border-radius: var(--radius-main);
            transition: all 0.5s;
        }
        
        /* 亮色模式修正主窗口边框 */
        html[data-theme="light"] #main-window {
            border: 1px solid #eee;
        }

        /* 赛博角标装饰 (通过变量控制显隐) */
        #main-window::before {
            content: ''; position: absolute; top: 0; left: 0; width: 20px; height: 20px;
            border-top: 2px solid var(--primary-color); border-left: 2px solid var(--primary-color); z-index: 10;
            display: var(--deco-display);
        }
        #main-window::after {
            content: ''; position: absolute; bottom: 0; right: 0; width: 20px; height: 20px;
            border-bottom: 2px solid var(--primary-color); border-right: 2px solid var(--primary-color); z-index: 10;
            display: var(--deco-display);
        }

        button {
            background: var(--btn-bg);
            border: 1px solid var(--secondary-color);
            color: var(--text-color);
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            font-weight: bold;
            font-size: 0.85rem;
            transition: all 0.3s;
            touch-action: manipulation;
            border-radius: var(--radius-main); /* 跟随主题变圆 */
        }
        
        html[data-theme="light"] button {
             border-color: transparent; /* 亮色模式默认无边框 */
             color: #888;
        }

        button:hover:not(:disabled) {
            background: var(--primary-color); 
            color: var(--bg-color); /* 亮色模式下文字变深，暗色模式下背景变黑，通用 */
            box-shadow: 0 0 15px var(--primary-color);
        }
        
        /* 亮色模式 Hover 修正：白色文字 */
        html[data-theme="light"] button:hover:not(:disabled) {
            color: #fff;
            box-shadow: 0 5px 15px rgba(255, 143, 171, 0.6); /* 柔和粉色阴影 */
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.3; cursor: not-allowed; border-color: #333; color: #666; background: transparent;
        }
        button.active {
            background: var(--primary-color); color: var(--bg-color);
        }
        html[data-theme="light"] button.active {
            color: #fff;
            box-shadow: 0 4px 10px rgba(255, 143, 171, 0.4);
        }

        /* --- 启动菜单 --- */
        #start-screen {
            flex: 1; width: 100%;
            background: var(--win-bg); /* 跟随主题 */
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 100;
            border-radius: var(--radius-main);
        }
        
        /* 亮色模式启动屏稍微透明一点 */
        html[data-theme="dark"] #start-screen { background: rgba(5, 10, 20, 0.98); }

        h1 {
            font-size: 2.2rem; color: var(--primary-color);
            text-shadow: var(--text-glow) var(--primary-color);
            margin-bottom: 2rem; letter-spacing: 4px; border-bottom: 2px solid;
            text-align: center;
            background: transparent;
        }
        /* 亮色模式 H1 修正 */
        html[data-theme="light"] h1 {
            border-bottom: 3px solid var(--primary-color); /* 更粗的线条 */
            border-radius: 2px;
            letter-spacing: 1px; /* 间距紧凑一点 */
        }

        .config-group { margin-bottom: 20px; text-align: center; width: 85%; }
        .config-title { color: var(--secondary-color); font-size: 0.7rem; margin-bottom: 8px; display: block; }
        .btn-group { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .btn-group button { flex: 1; padding: 10px 0; font-size: 0.8rem; min-width: 80px; }
        #start-btn { margin-top: 30px; font-size: 1.1rem; padding: 12px 50px; border-color: var(--primary-color); }
        html[data-theme="light"] #start-btn { 
            background: var(--primary-color); color: #fff; box-shadow: 0 5px 20px rgba(255,143,171,0.4);
        }

        /* --- 主题切换按钮 (仅控制位置) --- */
        .theme-switch {
            /* 1. 绝对定位到右上角 */
            position: absolute !important; /* 加重要级防止被flex布局干扰 */
            top: 20px;
            right: 20px;
            z-index: 102;
            
            /* 2. 重置外边距，防止位置偏移 */
            margin: 0 !important;
            
            /* 3. 尺寸微调 (可选) */
            /* 如果觉得普通按钮太大，可以稍微改小 padding，否则就删掉下面这就行 */
            padding: 8px 15px; 
            min-width: auto; /*不仅限于80px*/
        }

        /* --- 游戏主界面 --- */
        #game-ui { display: none; flex-direction: column; width: 100%; flex: 1; min-height: 0; }

        .top-bar {
            min-height: 50px;
            display: flex; align-items: center; justify-content: space-between;
            padding: 10px 20px;
            background: rgba(0, 243, 255, 0.03);
            border-bottom: 1px solid rgba(0, 243, 255, 0.1);
            flex-shrink: 0; flex-wrap: wrap; gap: 10px;
            
            border-top-left-radius: var(--radius-main);
            border-top-right-radius: var(--radius-main);
        }
        html[data-theme="light"] .top-bar {
            background: rgba(255,255,255,0.8);
            border-bottom: 1px solid #eee;
        }

        .stat-group { display: flex; gap: 20px; align-items: center; flex-wrap: wrap; }
        .stat-item { display: flex; flex-direction: row; gap: 8px; align-items: baseline; }
        .stat-label { font-size: 0.7rem; color: var(--secondary-color); }
        .stat-val { font-size: 1rem; font-weight: bold; min-width: 25px; text-shadow: var(--text-glow) var(--primary-color); }
        html[data-theme="light"] .stat-val { color: var(--text-color); }
        
        .menu-btns { display: flex; gap: 10px; }
        .menu-btns button { padding: 5px 12px; font-size: 0.7rem; height: 30px; }

        @media (max-width: 600px) {
            .top-bar { justify-content: center; padding: 10px; }
            .stat-group { width: 100%; justify-content: space-around; border-bottom: 1px dashed rgba(0, 243, 255, 0.1); padding-bottom: 8px; margin-bottom: 2px; }
            .menu-btns { width: 100%; justify-content: center; }
            .stat-group { gap: 10px; }
            h1 { font-size: 1.8rem; }
        }

        .progress-area { height: 4px; width: 100%; background: #111; position: relative; flex-shrink: 0; }
        html[data-theme="light"] .progress-area { background: #eee; }
        #timer-bar { 
            height: 100%; 
            background: var(--primary-color); 
            width: 0%; /* 默认从0开始 */
            transition: width 0.1s linear; /* 配合 JS 的 100ms 更新频率，保持丝滑 */
        }

        /* --- 卡牌区 --- */
        #card-container {
            flex: 1; display: flex; justify-content: center; align-items: center; align-content: center;
            flex-wrap: wrap; gap: 10px; padding: 15px; overflow-y: auto; position: relative;
            touch-action: none; user-select: none;
        }

        .card {
            width: var(--card-w); height: var(--card-h);
            border: 1px solid var(--secondary-color);
            background: var(--card-bg); /* 使用变量 */
            color: var(--secondary-color);
            display: flex; justify-content: center; align-items: center;
            font-size: 1.8rem; font-weight: bold;
            cursor: pointer; position: relative; 
            
            transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.1s ease-out, background-color 0.6s ease-out, border-color 0.6s ease-out, color 0.6s ease-out, box-shadow 0.6s ease-out;
            
            clip-path: polygon(6px 0, 100% 0, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0 100%, 0 6px);
            user-select: none; -webkit-user-select: none;
            
            opacity: 1; transform: translateY(0) scale(1);
        }
        
        /* 亮色模式卡牌修正：圆角、实心 */
        html[data-theme="light"] .card {
            clip-path: none;
            border-radius: 12px;
            border: 2px solid #f0f0f0;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
            color: #555;
        }

        .card.card-hidden {
            opacity: 0; transform: translateY(-60px) scale(1.1); pointer-events: none;
            background-color: var(--primary-color) !important;
            color: #000 !important;
            border-color: var(--primary-color) !important;
            box-shadow: 0 0 30px var(--primary-color) !important;
        }
        /* 亮色模式隐身卡牌修正：白色文字 */
        html[data-theme="light"] .card.card-hidden {
            color: #fff !important;
            box-shadow: 0 10px 30px rgba(255, 143, 171, 0.6) !important;
        }

        .card:hover { 
            background: rgba(0, 243, 255, 0.15); border-color: var(--primary-color); color: var(--primary-color); box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            transform: translateY(-2px);
        }
        html[data-theme="light"] .card:hover {
            background: #fff;
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }

        .card.selected {
            transform: translateY(-12px);
            border-color: #fff; color: #fff;
            background: rgba(0, 243, 255, 0.25); box-shadow: 0 0 15px var(--primary-color); z-index: 5;
        }
        html[data-theme="light"] .card.selected {
            background: var(--primary-color);
            border-color: var(--primary-color);
            box-shadow: 0 8px 25px rgba(255, 143, 171, 0.6);
            transform: translateY(-10px);
        }
        
        /* 按键提示通用样式 */
        .key-hint {
            position: absolute; top: 2px; left: 5px; font-size: 0.6rem;
            font-family: inherit; font-weight: bold; line-height: 1; z-index: 10;
            color: currentColor; opacity: 0.5; transition: opacity 0.2s, color 0.2s; pointer-events: none;
        }

        html[data-theme="light"] .key-hint {
            top: 6px;   /* 原本是 2px */
            left: 10px; /* 原本是 5px */
        }
        
        button:hover .key-hint, button.active .key-hint, button.ready .key-hint { opacity: 0.8; }
        .hint-hide { display: none !important; }
        .card .key-hint { top: 4px; left: 6px; color: var(--primary-color); opacity: 0.8; }
        html[data-theme="light"] .card .key-hint { color: var(--text-color); opacity: 0.4; }
        button { position: relative !important; }

        /* 底部控制栏 */
        .bottom-bar {
            min-height: 70px; height: auto;
            display: flex; align-items: center; justify-content: flex-end;
            gap: 15px; padding: 10px 20px;
            border-top: 1px solid rgba(0, 243, 255, 0.1); background: rgba(0,0,0,0.2);
            flex-shrink: 0; flex-wrap: wrap; padding-bottom: calc(10px + env(safe-area-inset-bottom));
            
            border-bottom-left-radius: var(--radius-main);
            border-bottom-right-radius: var(--radius-main);
        }
        html[data-theme="light"] .bottom-bar {
            background: #fff; border-top: 1px solid #f0f0f0;
        }

        #msg-display { margin-right: auto; color: var(--secondary-color); font-size: 0.8rem; letter-spacing: 2px; width: 100%; text-align: center; margin-bottom: 5px; }
        @media (min-width: 601px) { #msg-display { width: auto; margin-bottom: 0; text-align: left; } }
        
        #btn-exec { min-width: 100px; }
        #btn-exec.ready { background: var(--primary-color); color: #000; box-shadow: 0 0 20px var(--primary-color); animation: pulse 1.5s infinite; }
        html[data-theme="light"] #btn-exec.ready { color: #fff; }
        
        @keyframes pulse { 50% { opacity: 0.7; box-shadow: 0 0 5px var(--primary-color); } }

        .suggest {
            background: var(--primary-color) !important; color: #000 !important;
            box-shadow: 0 0 20px var(--primary-color); animation: pulse 1.5s infinite; border-color: #fff !important;
        }
        html[data-theme="light"] .suggest { color: #fff !important; }

        /* All In 按钮：默认暗色模式 (保留赛博蓝光) */
        #btn-all {
            display: none; 
            border-color: var(--primary-color); 
            color: var(--primary-color);
            /* 注意：这里原先写死了青色背景和阴影 */
            background: rgba(0, 243, 255, 0.1); 
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2); 
            margin-right: 5px;
        }

        /* 暗色模式 Hover */
        #btn-all:hover { 
            background: var(--primary-color); 
            color: #000; 
            box-shadow: 0 0 20px var(--primary-color);
        }

        /* === 修复：亮色模式下覆盖掉蓝光 === */
        html[data-theme="light"] #btn-all {
            /* 1. 背景改回纯白 */
            background: #fff !important; 
            
            /* 2. 阴影改回柔和的粉色 (或者是透明)，去掉原本的蓝色发光 */
            box-shadow: 0 2px 8px rgba(255, 143, 171, 0.3) !important;
            
            /* 3. 边框和文字跟随主题色(粉色) */
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        /* 亮色模式 Hover */
        html[data-theme="light"] #btn-all:hover {
            background: var(--primary-color) !important; 
            color: #fff !important;
            box-shadow: 0 5px 15px rgba(255, 143, 171, 0.6) !important;
        }

        #btn-clear { display: none; border-color: var(--alert-color); color: var(--alert-color); background: rgba(255, 42, 109, 0.1); margin-right: 5px; }
        #btn-clear:hover { background: var(--alert-color); color: #000; }
        html[data-theme="light"] #btn-clear { background: #fff; }
        html[data-theme="light"] #btn-clear:hover { background: var(--alert-color); color: #fff; }

        .footer-bar {
            height: calc(40px + env(safe-area-inset-bottom)); padding-bottom: env(safe-area-inset-bottom);
            flex-shrink: 0; display: flex; justify-content: center; align-items: center;
            border-top: 1px solid rgba(0, 243, 255, 0.05); background: rgba(0, 0, 0, 0.4);
            color: var(--secondary-color); font-size: 0.6rem; letter-spacing: 2px; text-shadow: var(--text-glow) var(--primary-color);
            animation: text-breathe 4s infinite ease-in-out;
        }
        html[data-theme="light"] .footer-bar { background: transparent; border: none; animation: none; color: #aaa; }
        @keyframes text-breathe { 0%, 100% { opacity: 0.4; } 50% { opacity: 0.8; text-shadow: 0 0 8px var(--primary-color); } }

        #game-over, #review-ui {
            display: none; position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(2, 4, 8, 0.98); z-index: 999;
            flex-direction: column; align-items: center; justify-content: center;
            border-radius: var(--radius-main);
        }
        html[data-theme="light"] #game-over, 
        html[data-theme="light"] #review-ui { 
            background: rgba(255, 255, 255, 0.95); 
        }

        .title-success { font-size: 3rem; color: var(--success-color); text-shadow: var(--text-glow) var(--success-color); margin-bottom: 10px; text-align: center; }
        .title-failure { font-size: 3rem; color: var(--alert-color); text-shadow: var(--text-glow) var(--alert-color), 0 0 10px var(--alert-color); margin-bottom: 10px; text-align: center; }
        .end-stat { font-size: 1rem; color: var(--text-color); margin-bottom: 5px; }

        #review-ui { align-items: stretch; flex-direction: row; background: #000; }
        #review-list { width: 180px; border-right: 1px solid #333; overflow-y: auto; background: rgba(0, 243, 255, 0.02); }
        html[data-theme="light"] #review-ui { background: #fff; }
        html[data-theme="light"] #review-list { background: #f9f9f9; border-right: 1px solid #eee; }

        .log-entry { padding: 15px; border-bottom: 1px solid #222; font-size: 0.75rem; color: #666; cursor: pointer; text-align: right; }
        html[data-theme="light"] .log-entry { border-bottom: 1px solid #eee; color: #999; }
        
        .log-entry:hover, .log-entry.active { background: #111; color: var(--primary-color); border-right: 3px solid var(--primary-color); }
        html[data-theme="light"] .log-entry:hover, 
        html[data-theme="light"] .log-entry.active { background: #fff; }

        #review-detail { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        
        #review-display { display: flex; gap: 15px; margin-bottom: 30px; flex-wrap: wrap; justify-content: center; width: 100%; padding-top: 20px; }
        #review-display.mini-view { gap: 10px; margin-bottom: 20px; }
        #review-display.mini-view .card { width: 50px; height: 75px; font-size: 1.4rem; border-width: 1px; }
        #review-display.mini-view .card.selected { transform: translateY(-8px) !important; }

        /* 头像挂件样式 (保持) */
        #profile-link {
            position: absolute; top: 20px; left: 20px;
            display: flex; align-items: center; gap: 10px; text-decoration: none;
            z-index: 101; transition: all 0.3s ease; cursor: pointer; user-select: none;
        }
        #profile-link:hover { filter: brightness(1.2); }
        #profile-link:hover img { box-shadow: 0 0 20px var(--primary-color); transform: scale(1.05) rotate(5deg); }
        #profile-link img {
            width: 45px; height: 45px; border-radius: 50%; border: 2px solid var(--primary-color);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2); background: #000; object-fit: cover; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .profile-info { display: flex; flex-direction: column; gap: 2px; }
        .profile-name { color: var(--text-color); font-size: 0.9rem; font-weight: bold; text-shadow: var(--text-glow) rgba(0, 243, 255, 0.5); font-family: var(--font-main); }
        .profile-role { color: var(--secondary-color); font-size: 0.6rem; letter-spacing: 2px; font-weight: bold; }

        /* 修复：亮色模式下头像的阴影 */
        html[data-theme="light"] #profile-link img {
            /* 1. 边框跟随主题色 (粉色) */
            border-color: var(--primary-color);
            
            /* 2. 阴影改为柔和的粉色投影，去掉青色发光 */
            box-shadow: 0 4px 10px rgba(255, 143, 171, 0.4);
        }

        /* 修复：亮色模式下名字去掉霓虹发光 */
        html[data-theme="light"] .profile-name {
            color: var(--text-color); /* 深灰色 */
            text-shadow: none;        /* 关掉发光 */
            font-weight: 800;         /*稍微加粗一点弥补去发光后的视觉重量 */
        }

        /* 修复：亮色模式下角色名 (LINK START) */
        html[data-theme="light"] .profile-role {
            color: #999; /* 浅灰色 */
        }

        /* 修复：亮色模式下头像 Hover 的效果 */
        html[data-theme="light"] #profile-link:hover img {
            /* 稍微加深阴影 */
            box-shadow: 0 6px 15px rgba(255, 143, 171, 0.6);
            transform: scale(1.05) rotate(5deg);
        }
        
        /* 移动端适配：屏幕变窄时 */
        @media (max-width: 600px) {
            /* 1. 不再隐藏整个连接，而是让它保持显示 */
            #profile-link { 
                display: flex; 
                /* 稍微调整位置，适配手机窄边框 */
                top: 15px;
                left: 15px;
            }

            /* 2. 只隐藏文字部分 */
            #profile-link .profile-info { 
                display: none; 
            }

            /* 3. (可选) 头像稍微缩小一点点，显得更精致 */
            #profile-link img {
                width: 40px;
                height: 40px;
            }
        }

        /* === 窗口抖动动画 === */
        @keyframes shake-window {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-6px); }
            75% { transform: translateX(6px); }
        }

        /* 激活抖动的类 */
        .anim-shake {
            /* 0.2秒快速抖动，覆盖原本的 transition */
            animation: shake-window 0.2s ease-in-out;
        }
    </style>
</head>
    
<body>
    <div id="main-window">
        <!-- 启动菜单 -->
        <div id="start-screen">
            <a id="profile-link" href="/">
                <img src="/avatar.jpg" alt="Avatar">
                <div class="profile-info">
                    <span class="profile-name">回到主页</span>
                    <span class="profile-role">LINK START</span>
                </div>
            </a>

            <button id="theme-btn-main" onclick="toggleTheme()" class="theme-switch">
                点缀
            </button>
            
            <h1>PROJECT: 24</h1>
            
            <div class="config-group">
                <span class="config-title">DATASET (牌库)</span>
                <div class="btn-group" id="opt-deck">
                    <button data-val="simple">简单</button>
                    <button data-val="classic">经典</button>
                    <button class="active" data-val="standard">标准</button>
                </div>
            </div>
            <div class="config-group">
                <span class="config-title">TIMER (计时)</span>
                <div class="btn-group" id="opt-time">
                    <button class="active" data-val="endless">无尽</button>
                    <button data-val="hourglass">沙漏</button>
                    <button data-val="breathing">呼吸</button>
                </div>
            </div>
            <div class="config-group">
                <span class="config-title">TOLERANCE (机会)</span>
                <div class="btn-group" id="opt-life">
                    <button data-val="casual">休闲 (3)</button>
                    <button class="active" data-val="challenge">挑战 (1)</button>
                    <button data-val="extreme">极限 (0)</button>
                </div>
            </div>
            <div class="config-group">
                <span class="config-title">LENGTH (赛程)</span>
                <div class="btn-group" id="opt-rounds">
                    <button class="active" data-val="1">基础 (1)</button>
                    <button data-val="10">耐久 (10)</button>
                    <button data-val="-1">无限 (∞)</button>
                </div>
            </div>
            <button id="start-btn">INITIATE</button>
        </div>

        <!-- 游戏界面 -->
        <div id="game-ui">
            <div class="top-bar">
                <div class="stat-group">
                    <div class="stat-item" id="round-display" style="display:none">
                        <span class="stat-label">RND:</span>
                        <span class="stat-val" id="round-val">1/1</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">DECK:</span>
                        <span class="stat-val" id="deck-val">--</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">TIME:</span>
                        <span class="stat-val" id="time-val">00:00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">CHANCES:</span>
                        <span class="stat-val" id="chance-val" style="color:var(--alert-color)">--</span>
                    </div>
                </div>
                <div class="menu-btns">
                    <button onclick="getHint()">HINT</button>
                    <button onclick="startGame()">RESTART</button>
                    <button onclick="backToMenu()">MENU</button>
                </div>
            </div>
            <div class="progress-area">
                <div id="timer-bar"></div>
            </div>
            <div id="card-container"></div>
            <div class="bottom-bar">
                <div id="msg-display">SYSTEM READY</div>
                <button id="btn-clear" onclick="clearSelection()">
                    <span class="key-hint">ESC</span>CLEAR
                </button>
                
                <button id="btn-all" onclick="selectAllAndExec()">
                    <span class="key-hint">↵</span>ALL IN
                </button>
                
                <button id="btn-draw">
                    <span class="key-hint">Q</span>DRAW
                </button>
                
                <button id="btn-exec" disabled>
                    <span class="key-hint">↵</span>EXECUTE
                </button>
            </div>
        </div>

        <div class="footer-bar">
            BUILD: 2025 // CREATOR: 点缀星空
        </div>

        <!-- 结算界面 -->
        <div id="game-over">
            <div id="end-title" class="title-failure">FAILURE</div>
            <div id="end-msg" style="margin-bottom:20px; letter-spacing:1px; color:#888">SIGNAL LOST</div>
            <div id="end-time" class="end-stat" style="margin-bottom: 5px; font-weight: bold; color: var(--primary-color)"></div>
            <div id="end-record" class="end-stat" style="font-size: 0.8rem; color: #666; margin-bottom: 5px; letter-spacing: 1px;"></div>
        
            <div id="end-config" class="end-stat" style="font-size: 0.7rem; color: #555; margin-bottom: 5px; font-family: var(--font-main); text-transform: uppercase;"></div>
            <div id="end-clears" class="end-stat" style="font-size: 0.85rem; color: var(--secondary-color); margin-bottom: 30px; letter-spacing: 1px; font-weight:bold;"></div>
            <div style="display:flex; gap:15px; flex-wrap: wrap; justify-content: center;">    <button onclick="openReview()">REVIEW</button>
                <button onclick="startGame()">RETRY</button>
                <button onclick="backToMenu()">MENU</button>
            </div>
        </div>

        <!-- 复盘 -->
        <div id="review-ui">
            <div id="review-list"></div>
            <div id="review-detail">
                <div id="review-display"></div>
                <div id="lbl-sol" style="color:#555; font-size:0.7rem; margin-bottom:15px;">SOLUTION DATA</div>
                <div id="review-sol" style="font-size:1.1rem; color:var(--primary-color)">[DATA PENDING]</div>
                <button onclick="$('review-ui').style.display='none'" style="margin-top:30px; border-color:var(--alert-color)">CLOSE</button>
            </div>
        </div>
    </div>

    <script>
        // 修改 cfg，增加 rounds 默认值
        const cfg = { deck:'standard', time:'endless', life:'challenge', rounds: 1 };
        
        // 修改 state，增加 round 计数器
        const state = {
            deck: [], hand: [], selection: [], history: [],
            chances: 0, timer: 0, interval: null, breath: 10.0,
            active: false, totalTime: 0,
            // 新增状态
            currentRound: 1, maxRounds: 1,
            hintUsed: false,
            lastTick: 0,
            lastRender: 0,
            animTimers: []
        };

        const solutionDB = new Map();
        let isDbReady = false;
        const $ = (id) => document.getElementById(id);
        
        // Setup
        document.querySelectorAll('.btn-group button').forEach(b => {
            b.onclick = (e) => {
                const p = e.target.parentElement;
                p.querySelectorAll('button').forEach(x => x.classList.remove('active'));
                e.target.classList.add('active');
                if(p.id==='opt-deck') cfg.deck = e.target.dataset.val;
                if(p.id==='opt-time') cfg.time = e.target.dataset.val;
                if(p.id==='opt-life') cfg.life = e.target.dataset.val;
                if(p.id==='opt-rounds') cfg.rounds = parseInt(e.target.dataset.val);

                localStorage.setItem('p24_last_config', JSON.stringify(cfg));
            }
        });

        $('start-btn').onclick = startGame;
        $('btn-draw').onclick = () => { drawCards(1); };
        $('btn-exec').onclick = execCards;

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function fmtTime(s) {
            let m = Math.floor(s/60);
            let sec = Math.floor(s%60);
            return `${m.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}`;
        }

        function fmtTimePrecise(s) {
            let m = Math.floor(s / 60);
            let sec = Math.floor(s % 60);
            // 提取毫秒 (3位)
            let ms = Math.floor((s % 1) * 1000); 
            return `${m.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}.${ms.toString().padStart(3,'0')}`;
        }

        function setStatus(msg, color) {
            const el = $('msg-display');
            el.innerText = msg;
            el.style.color = color;
        }

        function startGame() {
            $('start-screen').style.display = 'none';
            $('game-over').style.display = 'none';
            $('review-ui').style.display = 'none';
            $('game-ui').style.display = 'flex';

            // 重置全局游戏状态
            state.active = true;
            state.totalTime = 0; 
            state.history = [];
            state.hintUsed = false;
            state.lastTick = Date.now();
            
            // 设置赛程
            state.maxRounds = cfg.rounds;
            state.currentRound = 1;

            if (state.maxRounds > 1) {
                $('round-display').style.display = 'flex'; // 多局模式：显示
            } else {
                $('round-display').style.display = 'none'; // 基础模式：隐藏
            }

            if(cfg.life === 'casual') state.chances = 3;
            else if(cfg.life === 'challenge') state.chances = 1;
            else state.chances = 0; // Extreme
            updateStats();
            
            // 启动时钟
            clearInterval(state.interval);
            state.interval = setInterval(tick, 16);

            // 进入第一轮
            startRound();
        }

        // 新增函数：专门处理单轮重置逻辑
        function startRound() {
            // 1. 清理
            state.hand = [];
            state.selection = [];
            $('card-container').innerHTML = '';

            // 2. 更新上方局数显示 (如果有)
            if (cfg.rounds === -1) {
                // 无限模式：只显示当前局数
                $('round-val').innerText = state.currentRound;
                // 确保 RND 栏显示
                $('round-display').style.display = 'flex';
            } else if (state.maxRounds > 1) {
                // 普通多局模式：显示 进度
                $('round-val').innerText = `${state.currentRound}/${state.maxRounds}`;
                $('round-display').style.display = 'flex';
            } else {
                // 基础模式：隐藏
                $('round-display').style.display = 'none';
            }

            // 3. 进度条视觉重置
            const timerBar = $('timer-bar');
            const progressArea = document.querySelector('.progress-area');
            timerBar.style.backgroundColor = 'var(--primary-color)';
            if (cfg.time === 'endless') {
                timerBar.style.width = '0%';
                progressArea.style.visibility = 'hidden';
            } else {
                progressArea.style.visibility = 'visible';
                timerBar.style.width = '100%'; 
            }

            // 4. 生成新牌库 (保持原样)
            let pool = [];
            if (cfg.deck === 'simple') {
                const highProb = [3, 4, 6, 12]; 
                for (let i = 1; i <= 13; i++) {
                    let count = highProb.includes(i) ? 8 : 4;
                    for (let k = 0; k < count; k++) pool.push(i);
                }
            } else if (cfg.deck === 'classic') {
                for (let i = 1; i <= 13; i++) {
                    for (let k = 0; k < 4; k++) pool.push(i);
                }
            } else { 
                for (let i = 1; i <= 13; i++) {
                    for (let k = 0; k < 4; k++) pool.push(i);
                }
                pool.push(14, 15);
            }
            state.deck = pool;
            shuffleArray(state.deck);
            
            $('deck-val').innerText = state.deck.length; 

            // 5. 重置机会
            // if(cfg.life === 'casual') state.chances = 3;
            // else if(cfg.life === 'challenge') state.chances = 1;
            // else state.chances = 0;
            // updateStats();

            // 6. 重置单局计时
            if(cfg.time === 'hourglass') state.timer = 60.0;
            else if(cfg.time === 'breathing') state.breath = 10.0;
            else state.timer = 0; 

            // 7. 发牌
            drawCards(10);
            
            setStatus("SYSTEM READY", "var(--secondary-color)");
            state.active = true;
        }

        function tick() {
            if(!state.active) {
                state.lastTick = Date.now();
                return;
            }

            // --- 1. 高频逻辑计算 (保持 16ms 一次，保证时间精准) ---
            let now = Date.now();
            let dt = (now - state.lastTick) / 1000;
            state.lastTick = now;
            state.totalTime += dt;

            // 计算时间数值
            if(cfg.time === 'endless') {
                state.timer += dt;
            } else if(cfg.time === 'hourglass') {
                state.timer -= dt;
                if(state.timer <= 0) { gameOver("TIME EXHAUSTED", false); return; }
            } else if(cfg.time === 'breathing') {
                state.breath -= dt;
                if(state.breath <= 0) {
                    fail("TIMEOUT");
                    state.breath = 10.0;
                }
            }

            // --- 2. 低频 UI 更新 (每 100ms 更新一次，解决卡顿) ---
            // 只有当距离上次渲染超过 100ms 时，才去动 DOM
            if (now - state.lastRender > 100) {
                state.lastRender = now;

                if(cfg.time === 'endless') {
                    $('time-val').innerText = fmtTime(state.timer);
                }
                else if(cfg.time === 'hourglass') {
                    $('time-val').innerText = Math.max(0, state.timer).toFixed(1);
                    let pct = (state.timer / 60) * 100;
                    $('timer-bar').style.width = pct + "%";
                }
                else if(cfg.time === 'breathing') {
                    let pct = (state.breath / 10.0) * 100;
                    $('timer-bar').style.width = pct + "%";
                    $('time-val').innerText = state.breath.toFixed(1);
                    
                    if(state.breath <= 3) $('timer-bar').style.backgroundColor = 'var(--alert-color)';
                    else $('timer-bar').style.backgroundColor = 'var(--primary-color)';
                }
            }
        }

        function drawCards(n) {
            if(state.hand.length >= 10) return;

            $('btn-draw').classList.remove('suggest');
            setStatus("READY", "var(--secondary-color)");

            for(let i=0; i<n; i++) {
                if(state.deck.length === 0) break;
                if(state.hand.length >= 10) break;
                let val = state.deck.pop();
                state.hand.push({ id: Math.random(), val: val, isNew: true });
            }
            
            sortHand();
            render(); 
            
            // 立即移除数据标记
            state.hand.forEach(c => c.isNew = false);

            // === 状态检查 ===
            if (isDbReady) {
                // 1. 优先检查：反向头奖 (满手牌无解 = 奇迹)
                if (state.hand.length === 10) {
                    if (!checkSolvability(state.hand)) {
                        const miracleHand = state.hand.map(c => c.val).join(', ');
                        setTimeout(() => {
                            gameOver(miracleHand, true, true); 
                        }, 1000);
                        return; // 如果触发奇迹，就不继续往下检查死路了
                    }
                }

                // 2. --- 修改重点：新增死路检查 ---
                // 条件：牌库空了 + 手牌没满(满了走上面) + 手牌不为空 + 无解
                if (state.deck.length === 0 && state.hand.length > 0) {
                    if (!checkSolvability(state.hand)) {
                        fail("DEAD END / STAGNATION"); // 触发失败扣血，理由：拖沓/死局
                    }
                }
            }
        }

        function sortHand() {
            state.hand.sort((a,b) => a.val - b.val);
        }

        // --- 视图更新 ---
       function updateButtonStates() {
            let sc = state.selection.length;
            let handLen = state.hand.length;
            
            // 1. Execute 按钮
            let btnExec = $('btn-exec');
            let canExec = (sc >= 2 && sc <= 4);
            
            if(canExec) {
                btnExec.disabled = false;
                btnExec.classList.add('ready');
                btnExec.innerHTML = `<span class="key-hint">↵</span>EXECUTE`; 
            } else {
                btnExec.disabled = true;
                btnExec.classList.remove('ready');
                let txt = sc < 2 ? "SELECT (2-4)" : "FULL";
                btnExec.innerHTML = `<span class="key-hint">↵</span>${txt}`;
            }

            // 2. All In 按钮
            let btnAll = $('btn-all');
            let showAllIn = (handLen >= 2 && handLen <= 4);
            
            if (showAllIn) {
                btnAll.style.display = 'block';
                if(!btnAll.querySelector('.key-hint')) {
                     btnAll.innerHTML = `<span class="key-hint">↵</span>ALL IN`;
                }
            } else {
                btnAll.style.display = 'none';
            }

            // 3. Clear 按钮 (修正：恢复逻辑，仅在选中 >= 2 张时显示按钮)
            let btnClear = $('btn-clear');
            if (sc >= 2) {
                btnClear.style.display = 'block';
                if(!btnClear.querySelector('.key-hint')) {
                    btnClear.innerHTML = `<span class="key-hint">ESC</span>CLEAR`;
                }
            } else {
                btnClear.style.display = 'none';
            }

            // --- 动态控制 Enter 提示显隐 ---
            const hintExec = btnExec.querySelector('.key-hint');
            const hintAll = btnAll.querySelector('.key-hint');

            if (canExec) {
                // Execute 激活：显示它的提示，隐藏 All In 的
                if(hintExec) hintExec.classList.remove('hint-hide');
                if(hintAll) hintAll.classList.add('hint-hide'); 
            } else {
                // Execute 禁用：隐藏它的提示
                if(hintExec) hintExec.classList.add('hint-hide');

                // 如果 All In 存在，显示 All In 的提示
                if (showAllIn) {
                    if(hintAll) hintAll.classList.remove('hint-hide');
                }
            }
        }

        // 强行触发布局重绘 (Reflow)
        // 这是让浏览器意识到“元素刚刚是隐藏的，现在要显示了”的关键，否则浏览器会合并操作导致没有动画
        function forceReflow() {
            return document.body.offsetHeight; 
        }

        function updateCardVisual(id) {
            const cardDiv = document.querySelector(`.card[data-id="${id}"]`);
            if (!cardDiv) return;
            const isSelected = state.selection.includes(id);
            
            if (isSelected) {
                // 如果还在入场隐身状态，移除它，让它现身
                cardDiv.classList.remove('card-hidden'); 
                cardDiv.classList.add('selected');
            } else {
                cardDiv.classList.remove('selected');
            }
        }

        function setCardSelection(id, shouldSelect) {
            const idx = state.selection.indexOf(id);
            if (shouldSelect) {
                if (idx === -1) {
                    // === 修改重点：FIFO 自动顶替逻辑 ===
                    // 如果已经选满了4张，用户又点了第5张
                    if (state.selection.length >= 4) {
                        // 1. 移除最早选入的那张 (数组头部)
                        const firstId = state.selection.shift(); 
                        // 2. 更新那张牌的视觉状态 (取消选中)
                        updateCardVisual(firstId); 
                    }
                    // =================================
                    
                    // 正常的选中逻辑
                    state.selection.push(id);
                    updateCardVisual(id);
                    updateButtonStates();
                }
            } else {
                // 取消选中逻辑 (保持不变)
                if (idx > -1) {
                    state.selection.splice(idx, 1);
                    updateCardVisual(id);
                    updateButtonStates();
                }
            }
        }

        function toggleSelect(id) {
            const idx = state.selection.indexOf(id);
            setCardSelection(id, idx === -1);
        }

        function render() {
            const container = $('card-container');
            
            // 1. 建立现有 DOM 的映射
            const existingNodes = new Map();
            Array.from(container.children).forEach(el => {
                if(el.dataset.id) existingNodes.set(parseFloat(el.dataset.id), el);
            });

            // === 新增：新牌计数器 ===
            // 专门记录这是本次 render 中遇到的第几张新牌，用于计算紧凑的延迟
            let newCardCounter = 0; 
            // ======================

            state.hand.forEach((c, index) => {
                let div = existingNodes.get(c.id);

                // --- 新卡牌逻辑 ---
                if (!div) {
                    div = document.createElement('div');
                    div.dataset.id = c.id;
                    div.onclick = () => toggleSelect(c.id);
                    div.className = 'card';
                    
                    if (c.isNew) {
                        div.classList.add('card-hidden');
                        void div.offsetWidth; // 强制重绘
                        
                        let delay = 16 + newCardCounter * 40;
                        newCardCounter++; 
                        
                        setTimeout(() => {
                            div.classList.remove('card-hidden');
                        }, delay);
                    }
                }

                // --- 更新内容 ---
                let keyLabel = (index + 1) % 10; 
                div.innerHTML = `<span class="key-hint">${keyLabel}</span>${c.val}`;

                container.appendChild(div);

                // --- 更新选中状态 ---
                const isSelected = state.selection.includes(c.id);
                if (isSelected && !div.classList.contains('selected')) {
                    div.classList.remove('card-hidden');
                    div.classList.add('selected');
                } else if (!isSelected && div.classList.contains('selected')) {
                    div.classList.remove('selected');
                }

                existingNodes.delete(c.id);
            });

            existingNodes.forEach(el => el.remove());

            $('deck-val').innerText = state.deck.length;
            updateDrawBtn();
            updateButtonStates();
        }

        function updateDrawBtn() {
            let btn = $('btn-draw');
            // 始终保留 Q 提示的 HTML 结构
            let hintHtml = `<span class="key-hint">Q</span>`;
            
            if(state.hand.length >= 10) { 
                btn.disabled = true; 
                btn.innerHTML = `${hintHtml}MAX`; 
            } else if(state.deck.length === 0) { 
                btn.disabled = true; 
                btn.innerHTML = `${hintHtml}EMPTY`; 
            } else { 
                btn.disabled = false; 
                btn.innerHTML = `${hintHtml}DRAW`; 
            }
        }

        // --- Touch ---
        let isSwiping = false;
        let swipeTargetState = true; 
        let touchedCardsInGesture = new Set(); 
        const container = $('card-container');

        container.addEventListener('touchstart', (e) => {
            if(e.cancelable) e.preventDefault();
            isSwiping = true; touchedCardsInGesture.clear();
            handleSwipe(e);
        }, { passive: false });

        container.addEventListener('touchmove', (e) => {
            if (!isSwiping) return;
            if(e.cancelable) e.preventDefault();
            handleSwipe(e);
        }, { passive: false });

        container.addEventListener('touchend', () => { isSwiping = false; touchedCardsInGesture.clear(); });
        container.addEventListener('touchcancel', () => { isSwiping = false; touchedCardsInGesture.clear(); });

        function handleSwipe(e) {
            const touch = e.touches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (!target) return;
            const cardDiv = target.closest('.card');
            if (cardDiv) {
                const cardId = parseFloat(cardDiv.dataset.id);
                if (isNaN(cardId)) return;
                if (touchedCardsInGesture.size === 0) {
                    const isSelected = state.selection.includes(cardId);
                    swipeTargetState = !isSelected;
                }
                if (!touchedCardsInGesture.has(cardId)) {
                    touchedCardsInGesture.add(cardId);
                    setCardSelection(cardId, swipeTargetState);
                }
            }
        }

        function selectAllAndExec() {
            state.selection = state.hand.map(c => c.id);
            state.selection.forEach(id => updateCardVisual(id));
            updateButtonStates();
            setTimeout(() => { execCards(); }, 150);
        }

        function clearSelection() {
            state.selection.forEach(id => {
                const cardDiv = document.querySelector(`.card[data-id="${id}"]`);
                if(cardDiv) cardDiv.classList.remove('selected');
            });
            state.selection = [];
            updateButtonStates();
        }

        // --- 检查当前手牌是否有任意解 ---
        function checkSolvability(hand) {
            if (!isDbReady) return true; // 数据库没好默认当成有解，防止误判
            
            const indices = hand.map((_, i) => i);
            // 检查 4张、3张、2张 的组合
            const trySizes = [4, 3, 2]; 

            for (let r of trySizes) {
                let combos = getCombinations(indices, r);
                for (let comboIndices of combos) {
                    let values = comboIndices.map(i => hand[i].val).sort((a, b) => a - b);
                    if (solutionDB.has(values.join(','))) {
                        return true; // 只要找到一个解，立刻返回 true
                    }
                }
            }
            return false; // 找遍了所有组合都没解
        }
        
        // --- Logic ---
        function execCards() {
            if(state.selection.length < 2 || state.selection.length > 4) return;
            if(!isDbReady) { setStatus("DB NOT READY", "var(--alert-color)"); return; }

            let selectedCards = state.hand.filter(c => state.selection.includes(c.id));
            let values = selectedCards.map(c => c.val);
            values.sort((a, b) => a - b);
            const key = values.join(',');
            const resultLine = solutionDB.get(key);
            
            if(resultLine) {
                // === 成功逻辑 ===
                setStatus("CALCULATION VALID", "var(--success-color)");
                
                // 呼吸模式奖励：重置时间
                if(cfg.time === 'breathing') state.breath = 10.0;
                
                // 记录成功历史
                state.history.push({ cards: selectedCards.map(c=>c.val), sol: resultLine, status: 'success' });

                // 核心变化：只有成功时才移除手牌
                state.hand = state.hand.filter(c => !state.selection.includes(c.id));
                state.selection = [];
                render(); 

                // 检查是否下一轮或通关
                if(state.active && state.hand.length === 0) {
                    
                    // === 修改重点：暂停游戏防止“双重重置” ===
                    state.active = false; // 暂停 tick 循环
                    
                    // 手动定格进度条为满格（视觉反馈：完美！）
                    if (state.barEl) {
                        state.barEl.style.transform = 'scaleX(1)';
                        if(cfg.time === 'breathing') state.barEl.style.backgroundColor = 'var(--primary-color)';
                    }
                    // -------------------------------------

                    if (cfg.rounds === -1 || state.currentRound < state.maxRounds) {
                        state.currentRound++;
                        let msg = cfg.rounds === -1 ? "WAVE CLEARED" : "NEXT PHASE";
                        setStatus(msg + "...", "var(--primary-color)");
                        setTimeout(() => {
                            startRound(); // startRound 里面现在会把 active 设回 true
                        }, 100); 
                    } else {
                        setTimeout(() => gameOver("MISSION COMPLETE", true), 100);
                    }
                } else if (state.active && state.hand.length > 0) {
                    // 只有当牌库空了，且手里还有牌，且没通关时检查
                    if (state.deck.length === 0) {
                        if (!checkSolvability(state.hand)) {
                            fail("DEAD END / STAGNATION"); // 触发失败扣血，理由：拖沓/死局
                        } else {
                            // 有解，恢复 Ready
                            setTimeout(() => { setStatus("READY", "var(--secondary-color)"); }, 800);
                        }
                    } else {
                        // 牌库还有牌，正常恢复 Ready
                        setTimeout(() => { setStatus("READY", "var(--secondary-color)"); }, 800);
                    }
                }

            } else {
                // 1. 先记录这手牌失败了
                state.history.push({ cards: selectedCards.map(c=>c.val), sol: null, status: 'fail' });
            
                // 2. 触发失败 (内部会调用 gameOver)
                fail("INVALID / NO SOLUTION"); 

                // 3. 如果没死（active还是true），才进行界面重置
                if (state.active) {
                    if(cfg.time === 'breathing') state.breath = 10.0;
                    clearSelection();
                }
            }
        }

        function fail(reason) {
            state.chances--;
            updateStats();
            
            // === 修改重点：使用 CSS Class 触发抖动 ===
            const win = $('main-window');
            
            // 1. 移除可能存在的类（防止连续失败时动画不触发）
            win.classList.remove('anim-shake');
            
            // 2. 强制浏览器重绘 (Reflow)，这是让动画能立刻再次触发的关键魔法
            void win.offsetWidth; 
            
            // 3. 添加类，开始抖动
            win.classList.add('anim-shake');
            
            // 4. 动画结束后清理（虽然不清理也行，但保持整洁）
            setTimeout(() => {
                win.classList.remove('anim-shake');
            }, 210); // 略大于动画时间的 0.2s
            // =======================================

            if(state.chances < 0) gameOver(reason, false);
        }

        function updateStats() {
            let disp = state.chances < 0 ? 0 : state.chances;
            $('chance-val').innerText = disp;
        }

        function getRecordKey() {
            return `p24_record_${cfg.deck}_${cfg.time}_${cfg.life}_${cfg.rounds}`;
        }
        
        function gameOver(msg, win, isMiracle = false) {
            state.active = false;
            clearInterval(state.interval);

            // 如果手里还有牌（无论是输了还是奇迹），都记录下来
            if (state.hand.length > 0) {
                state.history.push({ 
                    cards: state.hand.map(c => c.val), 
                    sol: null, // 剩余手牌通常不需要显示特定解法（或者由系统后续判断），这里置空
                    status: 'remaining' // 特殊状态标记
                });
            }
            
            $('game-over').style.display = 'flex';
            const title = $('end-title');
            const msgEl = $('end-msg');
            const recordEl = $('end-record');
            const timeEl = $('end-time');
            
            // --- 0. 计算分数 (无限模式) ---
            // 核心修正：无论是不是奇迹，无限模式下，当前这局都没过（或者不算过）
            // 所以分数永远是 currentRound - 1
            let survivalScore = 0;
            if (cfg.rounds === -1) {
                survivalScore = Math.max(0, state.currentRound - 1);
            }

            // --- 1. 标题与样式处理 (UI层) ---
            if (isMiracle) {
                title.innerText = "LEGENDARY"; 
                title.style.color = "#FFD700"; 
                title.style.textShadow = "0 0 20px #FFD700, 0 0 40px #FF4500";
                msgEl.innerHTML = `<span style="font-size:0.8rem; color:#aaa; display:block; margin-bottom:5px;">IMPOSSIBLE HAND DISCOVERED</span><span style="color:#fff; font-size:1.2rem; font-family:monospace">[ ${msg} ]</span>`;
            } 
            else {
                // 恢复默认样式
                title.style.color = ""; 
                title.style.textShadow = "";
                msgEl.innerText = msg;

                if (cfg.rounds === -1) {
                    if (survivalScore > 0) {
                        title.innerText = "RUN ENDED";
                        title.className = "title-success";
                    } else {
                        title.innerText = "FAILURE";
                        title.className = "title-failure";
                    }
                } else {
                    title.innerText = win ? "SUCCESS" : "FAILURE";
                    title.className = win ? "title-success" : "title-failure";
                }
            }

            // --- 2. 中间大字数据显示 ---
            if (cfg.rounds === -1) {
                timeEl.innerText = `ROUNDS CLEARED: ${survivalScore}`;
                timeEl.style.color = "var(--primary-color)";
            } else {
                timeEl.innerText = "TOTAL TIME: " + fmtTimePrecise(state.totalTime);
            }

            // --- 3. 记录判定逻辑 (核心修正) ---
            const key = getRecordKey();
            const lastRecord = localStorage.getItem(key);
            let bestVal = lastRecord ? parseFloat(lastRecord) : null;

            if (state.hintUsed) {
                recordEl.innerText = "RECORD INVALID (ASSISTED)";
                recordEl.style.color = "var(--alert-color)";
                recordEl.style.animation = "none";
            }
            // === 情况 A: 无限模式 ===
            else if (cfg.rounds === -1) {
                // 在无限模式下，只有生存分数 > 0 才具备“刷新记录”的资格
                // 这相当于竞速模式下的 "Win"
                if (survivalScore > 0) {
                    if (bestVal === null || survivalScore > bestVal) {
                        localStorage.setItem(key, survivalScore);
                        recordEl.innerText = "NEW RECORD UPDATED";
                        recordEl.style.color = "var(--success-color)";
                        recordEl.style.animation = "pulse 1s infinite";
                    } else {
                        recordEl.innerText = `BEST RECORD: ${bestVal} RNDS`;
                        recordEl.style.color = "#888"; 
                        recordEl.style.animation = "none";
                    }
                } 
                // 如果得分是 0 (第1局就挂了)，相当于竞速模式下的 "Fail"
                // 此时不更新记录，只展示已有记录或 NO RECORD
                else {
                    if (bestVal !== null) {
                        recordEl.innerText = `BEST RECORD: ${bestVal} RNDS`;
                    } else {
                        recordEl.innerText = "NO RECORD";
                    }
                    recordEl.style.color = "#666";
                    recordEl.style.animation = "none";
                }
            }
            // === 情况 B: 普通竞速模式下的 Miracle ===
            else if (isMiracle) {
                 // 竞速模式下，Miracle 不计入时间成绩
                 recordEl.innerText = "RECORD UNAFFECTED";
                 recordEl.style.color = "#FFD700";
                 recordEl.style.animation = "none";
            }
            // === 情况 C: 普通竞速模式下的正常胜利 ===
            else if (win) {
                if (bestVal === null || state.totalTime < bestVal) {
                    localStorage.setItem(key, state.totalTime);
                    recordEl.innerText = "NEW RECORD UPDATED";
                    recordEl.style.color = "var(--success-color)";
                    recordEl.style.animation = "pulse 1s infinite"; 
                } else {
                    recordEl.innerText = `BEST RECORD: ${fmtTimePrecise(bestVal)}`;
                    recordEl.style.color = "#888";
                    recordEl.style.animation = "none";
                }
            } 
            else {
                // 普通失败
                if (bestVal !== null) {
                    recordEl.innerText = `BEST RECORD: ${fmtTimePrecise(bestVal)}`;
                } else {
                    recordEl.innerText = "NO RECORD";
                }
                recordEl.style.color = "#666";
                recordEl.style.animation = "none";
            }

            
            // === 1. 显示游戏配置 (Config) ===
            // 定义映射表，方便显示漂亮的文本
            const deckMap = { 'simple': 'SIMPLE', 'classic': 'CLASSIC', 'standard': 'STANDARD' };
            const timeMap = { 'endless': 'ENDLESS', 'hourglass': 'HOURGLASS', 'breathing': 'BREATHING' };
            const lifeMap = { 'casual': 'CASUAL', 'challenge': 'CHALLENGE', 'extreme': 'EXTREME' };
            // 赛程特殊处理
            let roundTxt = cfg.rounds;
            if (cfg.rounds === 1) roundTxt = 'BASE';
            else if (cfg.rounds === 10) roundTxt = 'ENDURANCE';
            else if (cfg.rounds === -1) roundTxt = 'INFINITE';

            // 拼接字符串：STANDARD / BREATHING / CHALLENGE / BASE
            const configStr = [
                deckMap[cfg.deck] || cfg.deck,
                timeMap[cfg.time] || cfg.time,
                lifeMap[cfg.life] || cfg.life,
                roundTxt
            ].join(' / ').toUpperCase();

            $('end-config').innerText = configStr;

            // === 2. 处理通关次数 (Mode Specific Clear Count) ===
            
            // 1. 构建当前模式的唯一键名 (与最佳纪录的键名逻辑保持一致)
            // 格式: p24_clears_standard_breathing_challenge_10
            const modeKeyRaw = `${cfg.deck}_${cfg.time}_${cfg.life}_${cfg.rounds}`;
            const clearKey = `p24_clears_${modeKeyRaw}`;
            
            // 2. 读取当前模式的通关数
            let modeClears = parseInt(localStorage.getItem(clearKey) || '0');

            // 3. 判定是否为有效通关 (逻辑保持不变)
            // - 普通模式: 赢了 (win)
            // - 无限模式: 只要没死在第1关 (survivalScore > 0)
            // - 排除: 奇迹结局 (isMiracle) 不计入
            const isStandardWin = (cfg.rounds !== -1 && win);
            const isInfiniteClear = (cfg.rounds === -1 && survivalScore > 0);
            
            const isValidClear = (isStandardWin || isInfiniteClear) && !isMiracle;

            // 4. 如果有效，计数+1 并保存
            if (isValidClear) {
                modeClears++;
                localStorage.setItem(clearKey, modeClears);
            }

            // 5. 显示文本
            const clearsEl = $('end-clears');
            // 修改文案为 "MODE CLEARS" 以体现这是当前模式的数据
            clearsEl.innerText = `MODE CLEARS: ${modeClears}`;
            
            // 样式处理：如果是有效通关，显示高亮绿色
            if (isValidClear) {
                clearsEl.style.color = "var(--success-color)";
                clearsEl.style.textShadow = "0 0 10px rgba(0, 255, 157, 0.3)";
            } else {
                clearsEl.style.color = "var(--secondary-color)";
                clearsEl.style.textShadow = "none";
            }
        }

        function backToMenu() {
            $('game-ui').style.display = 'none';
            $('game-over').style.display = 'none';
            $('start-screen').style.display = 'flex';
            state.active = false;
            clearInterval(state.interval);
        }

        function openReview() {
            $('review-ui').style.display = 'flex';
            let list = $('review-list');
            let cardDisplay = $('review-display');
            let solDisplay = $('review-sol');
            let lblSol = $('lbl-sol'); // 获取标签元素

            list.innerHTML = ''; cardDisplay.innerHTML = ''; solDisplay.innerText = ''; 
            
            if (state.history.length === 0) {
                // 没记录时特殊处理一下显隐
                lblSol.style.display = 'block';
                solDisplay.style.display = 'block';
                solDisplay.innerText = "NO RECORDS";
                solDisplay.style.color = "var(--secondary-color)";
                return;
            }

            // 倒序遍历，让最新的在最上面
            [...state.history].reverse().forEach((h, i) => {
                let d = document.createElement('div');
                d.className = 'log-entry';
                let originalIndex = state.history.length - i;

                if (h.status === 'remaining') {
                    d.innerText = `[REMAINING]`; 
                    d.style.color = "var(--secondary-color)";
                    d.style.letterSpacing = "1px";
                } else {
                    if(h.status === 'fail') d.style.color = 'var(--alert-color)';
                    d.innerText = `[${originalIndex.toString()}]  ${h.cards.join(' ')}`;
                }

                d.onclick = function() {
                    Array.from(list.children).forEach(child => child.classList.remove('active'));
                    d.classList.add('active');

                    if (h.cards.length > 6) {
                        cardDisplay.classList.add('mini-view');
                    } else {
                        cardDisplay.classList.remove('mini-view');
                    }
                    
                    cardDisplay.innerHTML = h.cards.map(v => 
                        `<div class="card selected" style="cursor:default">${v}</div>`
                    ).join('');
                    
                    // === 修改重点：控制右侧显隐 ===
                    if (h.status === 'remaining') {
                        // 如果是剩余手牌，隐藏解法相关文字
                        lblSol.style.display = 'none';
                        solDisplay.style.display = 'none';
                    } else {
                        // 如果是普通记录，显示并填充内容
                        lblSol.style.display = 'block';
                        solDisplay.style.display = 'block';
                        
                        if (h.sol) {
                            solDisplay.innerText = h.sol;
                            solDisplay.style.color = "var(--primary-color)";
                        } else {
                            solDisplay.innerText = "NO SOLUTION / INVALID";
                            solDisplay.style.color = "var(--alert-color)";
                        }
                    }
                };
                list.appendChild(d);
            });
            
            // 默认选中第一项（也就是倒序后的最新一项）
            if (list.firstChild) list.firstChild.click();
        }

        // --- 新增：提示功能 ---
        function getHint() {
            if (!state.active || !isDbReady) return;

            state.hintUsed = true;

            clearSelection();
            $('btn-draw').classList.remove('suggest');

            const hand = state.hand;
            const indices = hand.map((_, i) => i); 

            // 优先找4张，其次3张，最后2张
            const trySizes = [4, 3, 2]; 

            for (let r of trySizes) {
                // 1. 获取当前张数的所有可能下标组合 (例如所有2张牌的组合)
                let combos = getCombinations(indices, r);
                
                // 如果有多个解，系统会随机挑一个，而不是永远选最左边的
                shuffleArray(combos); 
                
                for (let comboIndices of combos) {
                    let candidateCards = comboIndices.map(i => hand[i]);
                    let values = candidateCards.map(c => c.val).sort((a, b) => a - b);
                    let key = values.join(',');

                    if (solutionDB.has(key)) {
                        candidateCards.forEach(c => toggleSelect(c.id));
                        setStatus("SOLUTION FOUND", "var(--success-color)");
                        return; 
                    }
                }
            }

            // 无解逻辑
            if (state.hand.length < 10) {
                setStatus("NO MOVES - DRAW CARD", "var(--primary-color)");
                $('btn-draw').classList.add('suggest');
            } else {
                // 如果运行到了，说明之前的自动检查漏了（可能是因为当时DB没加载好）
                setStatus("DEADLOCK / DB LAG", "var(--alert-color)");
            }
        }

        // 辅助函数：生成数组 arr 中取 k 个元素的所有组合
        function getCombinations(arr, k) {
            let i, subI, ret = [], sub, next;
            for (i = 0; i < arr.length; i++) {
                if (k === 1) {
                    ret.push([arr[i]]);
                } else {
                    sub = getCombinations(arr.slice(i + 1), k - 1);
                    for (subI = 0; subI < sub.length; subI++) {
                        next = sub[subI];
                        next.unshift(arr[i]);
                        ret.push(next);
                    }
                }
            }
            return ret;
        }

        async function loadData() {
            setStatus("LOADING DATA...", "var(--primary-color)");

            // 内部辅助函数：解析文本并填入 Map
            const processData = (text) => {
                solutionDB.clear();
                text.split('\n').forEach(line => {
                    line = line.trim();
                    if (!line || !line.includes('=')) return; 
                    let nums = line.replace(/[^\d]/g, ' ').trim().split(/\s+/).map(Number);
                    nums.pop(); 
                    nums.sort((a, b) => a - b);
                    solutionDB.set(nums.join(','), line);
                });
            };

            try {
                // 1. 优先尝试网络请求
                const response = await fetch('https://stellate0511.github.io/Project-24/database.txt');
                if (!response.ok) throw new Error("Network connection failed");
                
                const text = await response.text();
                
                // 2. 网络加载成功：解析数据
                processData(text);
                
                // 3. 核心修改：将成功获取的数据存入本地缓存
                try {
                    localStorage.setItem('p24_db_cache', text);
                    console.log("Database cached to LocalStorage.");
                } catch (e) {
                    console.warn("Cache write failed (storage full?)", e);
                }

                isDbReady = true;
                setStatus("SYSTEM READY", "var(--secondary-color)");
                console.log(`Database loaded (Online): ${solutionDB.size} entries.`);

            } catch (err) {
                console.warn("Network load failed, attempting fallback...", err);
                
                // 4. 网络失败：尝试读取本地缓存
                const cachedText = localStorage.getItem('p24_db_cache');
                
                if (cachedText) {
                    // 5. 缓存命中：使用缓存数据
                    processData(cachedText);
                    isDbReady = true;
                    // 给用户一个小提示：当前是离线模式
                    setStatus("READY (OFFLINE)", "var(--secondary-color)");
                    console.log(`Database loaded (Cache): ${solutionDB.size} entries.`);
                } else {
                    // 6. 彻底失败（既没网也没缓存）
                    console.error("Critical: No network and no cache.");
                    setStatus("DB LOAD FAIL", "var(--alert-color)");
                    alert("连接失败，且无本地缓存数据！");
                }
            }
        }
        loadData();

        // --- 自动加载上次的菜单选项 ---
        function loadLastConfig() {
            const saved = localStorage.getItem('p24_last_config');
            if (!saved) return; // 如果没有记录，使用默认值

            try {
                const parsed = JSON.parse(saved);
                // 更新 cfg 对象
                Object.assign(cfg, parsed);

                // 辅助函数：更新UI选中状态
                const setUI = (groupId, val) => {
                    const group = $(groupId);
                    if (!group) return;
                    // 移除该组所有 active
                    group.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    // 找到对应值的按钮并激活
                    // 注意：dataset.val 都是字符串，所以这里要把 val 转字符串匹配
                    const target = group.querySelector(`button[data-val="${val}"]`);
                    if (target) target.classList.add('active');
                };

                setUI('opt-deck', cfg.deck);
                setUI('opt-time', cfg.time);
                setUI('opt-life', cfg.life);
                setUI('opt-rounds', cfg.rounds);

            } catch (e) {
                console.error("Config load error", e);
            }
        }
        // 立即执行加载
        loadLastConfig();

        // --- 新增：键盘事件监听 ---
        document.addEventListener('keydown', (e) => {
            // 如果不在游戏活跃状态，或者正在显示遮罩层，不响应按键
            if (!state.active || $('game-over').style.display === 'flex' || $('review-ui').style.display === 'flex') return;

            const key = e.key.toLowerCase();

            // 1. 处理数字键 1-9 和 0 (对应卡牌)
            if (/\d/.test(key)) {
                let num = parseInt(key);
                // 逻辑转换：按键1->索引0 ... 按键0->索引9
                let targetIndex = (num === 0) ? 9 : num - 1;
                
                // 确保手牌里有这张牌
                if (state.hand[targetIndex]) {
                    toggleSelect(state.hand[targetIndex].id);
                    // 添加一个按下的视觉反馈效果（可选）
                    const cardEl = document.querySelectorAll('.card')[targetIndex];
                    if(cardEl) {
                        cardEl.style.transform = "scale(0.95)";
                        setTimeout(() => cardEl.style.transform = "", 100);
                    }
                }
                return;
            }

            // 2. 功能键
            switch(key) {
                case 'q': // Q - 摸牌
                    if (!$('btn-draw').disabled) {
                        drawCards(1);
                        simulateClick('btn-draw');
                    }
                    break;
                    
                case 'escape': // Esc - 取消选择
                    if (state.selection.length > 0) {
                        clearSelection();
                        simulateClick('btn-clear');
                    }
                    break;
                    
                case 'enter': // Enter - 智能判断
                    // 逻辑修正：优先响应“Execute”（手动出牌）
                    // 只有当不能 Execute 时，才尝试响应 “All In”
                    
                    if (!$('btn-exec').disabled) {
                        // 情况1：已选中2-4张牌 -> 执行出牌
                        execCards();
                        simulateClick('btn-exec');
                    } 
                    else if ($('btn-all').style.display === 'block') {
                        // 情况2：未满足出牌条件，但满足All In条件（手牌共2-4张） -> 全选并执行
                        selectAllAndExec();
                        simulateClick('btn-all');
                    }
                    break;
            }
        });

        // 辅助函数：给按钮增加点击的视觉反馈
        function simulateClick(btnId) {
            const btn = $(btnId);
            if(btn) {
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 150);
            }
        }
        
        document.addEventListener('click', (e) => {
            // 查找被点击元素是否是 button 或在 button 内部
            const btn = e.target.closest('button');
            if (btn) {
                btn.blur(); // 强制移除焦点
            }
        }, true);

        // === 主题控制系统 ===
        
        // 初始化
        function initTheme() {
            // 读取保存的主题，没有则默认为 'dark'
            const savedTheme = localStorage.getItem('p24_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeBtnText(savedTheme);
        }

        // 切换逻辑
        function toggleTheme() {
            const current = document.documentElement.getAttribute('data-theme');
            // 如果是 dark，切到 light；反之亦然
            const next = current === 'dark' ? 'light' : 'dark';
            
            // 1. 设置属性 -> CSS 自动变身
            document.documentElement.setAttribute('data-theme', next);
            
            // 2. 保存到本地存储
            localStorage.setItem('p24_theme', next);
            
            // 3. 更新按钮文字
            updateThemeBtnText(next);
        }

        // 更新按钮文字
        function updateThemeBtnText(theme) {
            // 获取两个按钮（启动页的大按钮，游戏内的小按钮）
            const btnMain = document.getElementById('theme-btn-main');
            const btnMini = document.getElementById('theme-btn-mini');
            
            // 逻辑：当前是 dark -> 显示 "点缀" (代表默认)
            //       当前是 light -> 显示 "星空" (代表新主题)
            //       或者你想反过来：按钮显示的是“点击后会变成的样子”？
            //       按你的描述："切换的地方是一个显示'点缀'的按钮，点击...会显示'星空'"
            //       这意味着：Dark模式下按钮字是"点缀"，Light模式下按钮字是"星空"。
            
            const text = theme === 'dark' ? '点缀' : '星空';
            
            if(btnMain) btnMain.innerText = text;
            if(btnMini) btnMini.innerText = text;
        }

        // 立即运行初始化
        initTheme();
    </script>
</body>
</html>
